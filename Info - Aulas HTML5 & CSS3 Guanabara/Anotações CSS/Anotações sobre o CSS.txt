
                                                         
                                              ==  PSEUDO-CLASSES E PSEUDO-ELEMENTOS  ==


==> # = id
==> .  = class
==> :  = pseudo - class
==> :: = pseudo - element
==> > = children (filho)


Sintaxe:

Para utilizar um pseudo-elemento basta declarar o seletor seguido pelo pseudo-elemento desejado. Logo após, da mesma forma que é feito com qualquer regra CSS, podemos definir as propriedades a ele relacionadas.

Sintaxe de declaração de um pseudo-elemento:

        [seletor]::pseudo-elemento { 
                propriedade : valor; 
        }


todos os pseudo-elementos do CSS (que eu conheço até o momento) :

::first-line, ::first-letter, ::before, ::after e ::selection, ::-webkit-scrollbar


 ::first-line =
O pseudo-elemento ::first-line é utilizado quando desejamos customizar o conteúdo apresentado na primeira linha de um elemento. Assim, podemos estilizar esse fragmento de texto de forma independente, aplicando, por exemplo, um tamanho de fonte diferente.

 ::first-letter =
O pseudo-elemento ::first-letter nos permite selecionar a primeira letra do conteúdo de um elemento. Usamos esse recurso quando desejamos destacar essa letra alterando seu tamanho e sua cor, por exemplo.

 ::before =
A declaração do pseudo-elemento ::before em um seletor cria um falso elemento que nos permite adicionar conteúdo antes do conteúdo do elemento selecionado.

 ::after =
Assim como ::before, o pseudo-elemento ::after também cria um falso elemento que nos permite adicionar conteúdo ao elemento selecionado, mas desta vez no final dele.

 ::selection =
O pseudo-elemento ::selection é utilizado para selecionar o conteúdo de um elemento e, a partir disso, customizar algumas propriedades dessa área, como a cor de fundo e do texto.

 :: -webkit-scrollbar =
O pseudo-elemento ::-webkit-scrollbar é utilizado para esconder as barras de rolagem do site. Ele é utilizado de forma solitária, ou seja, não se utiliza depois de uma propriedade CSS.



Todas as pseudo-classes do CSS (que eu conheço até o momento) :

:hover, :nth-child(), :focus, :root, :visited

 :hover =
A pseudo-classe :hover corresponde quando o usuário designa um elemento com um dispositivo apontador, mas não necessariamente o ativa. Este estilo pode ser substituído por qualquer outra pseudo-classe de link-relacionados, isto é :link, :visited, e :active, aparecendo em regras subsequentes. Na ordem para estilizar apropriadamente links, você precisa colocar a regra:hoverdepois das regras :link e :visited mas antes da regra :active, como definido pela ordem LVHA: :link — :visited — :hover — :active.

 :nth-child() = 
A pseudo-classe CSS :nth-child() seleciona elementos com base em suas posições em um grupo de elementos irmãos.

 :focus =
A pseudo-classe :focus do CSS é aplicada quando um elemento recebe foco, o que pode ocorrer quando o usuário seleciona o elemento utilizando o teclado ou ativando o mesmo com o mouse (ex: um campo de um formulário).
A pseudo classe é aplicada apenas ao elemento focado, e não aos seus elementos ascendentes, como ocorre com :checked e :enabled e diferentemente de :active ou :hover.

 :root =
O :root pode ser útil para declarar variáveis CSS global:

 :visited =
O :visited é uma Pseudo-classe do CSS para indicar se o link em questão já foi visitado pelo usuário. Por questões de privacidade, os styles que podem ser modificados usando este seletor são muito limitados.


Para saber mais sobre Pseudo-Elementos e Pseudo-Classes acesse os links abaixo:

==> PSEUDO-CLASSES 
https://developer.mozilla.org/pt-BR/docs/Web/CSS/Pseudo-classes
https://www.w3schools.com/css/css_pseudo_classes.asp

==> PSEUDO-ELEMENTOS
https://www.devmedia.com.br/css-conheca-os-pseudo-elementos/38183


                                                          
                                                            ==  MODELO DE CAIXAS  ==


O que é uma caixa?

De forma simples e objetiva, baseado em um conceito chamado “box model”, a grande maioria dos elementos HTML que temos no nosso site são como caixas. Elas são containers que armazenam conteúdos ou até mesmo outras caixas. 


Anatomia de uma caixa:

Vamos analisar como uma caixa vai ser apresentada por todos os navegadores. Olhe atentamente o PDF Modelos de caixas na página 3, lá tem um diagrama, que é exatamente o já citado Box model:


Tipos de Caixa:

==> CAIXA DO TIPO BLOCK-LEVEL:

Um elemento dito block-level sempre vai se iniciar em uma nova linha e vai ocupar a
largura total do elemento onde ele está contido. Se não estiver contido em nenhuma
outra caixa, ele vai ocupar 100% da largura do <body>.

O elemento block-level mais conhecido é o <div> e suas variações semânticas
modernas da HTML5, como <main>, <section>, <aside>, etc.

Na lista a seguir, coloquei alguns elementos HTML que são block-level:

==>  <address>  <article>  <aside>  <blockquote>  <canvas>  <dd>  <div>  <dl>  <dt>  <fieldset> 

==>  <figcaption>  <figure>  <footer>  <form>  <h1> - <h6>  <header>  <hr>  <li>  <main>  <nav>  

==>  <noscript>  <ol>  <p>  <pre>  <section>  <table>  <tfoot>  <ul>  <video>


==> CAIXA DO TIPO INLINE-LEVEL:

Um elemento do tipo inline-level não vai começar em uma nova linha, e sim no ponto
exato onde foram definidos. E a largura dele vai ocupar apenas o tamanho relativo ao
seu conteúdo.

Abaixo, listei alguns elementos inline-level usados pela HTML:

==>  <a>  <abbr>  <acronym>  <b>  <bdo>  <br>  <button>  <cite>  <code>  <dfn>  <em>  <i>

==>  <img>  <input>  <kbd>  <label>  <map>  <object>  <output>  <q>  <samp>  <script>  <select>  

==>  <small>  <span>  <strong>  <sub>  <textarea>  <tt>  <var>



                                         ==  ORDEM DE CONFIGURAÇÃO DAS CAIXAS  ==


==> BORDA E CONTORNO PERSONALIZADOS:


As configurações de border e outline também possuem shorthands para simplificar o código anterior.

A ordem para as duas configurações é sempre a mesma para as duas shorthands: 

==> Border e outline -> largura (-width), estilo (-style) e cor (-color).
Ex ==>  border: 20px solid blue;
Ex ==>  outline: 20px dashed red;


==> PREENCHIMENTO E MARGEM PERSONALIZADOS:


Todo elemento de caixa possui quatro valores para padding e quatro para margin, sempre nessa mesma ordem: 

==> superior (-top), direita (-right), inferior (-bottom),esquerda (-left). 

Ex ==> padding: 10px 5px 15px 5px;
Ex ==> margin: 10px 5px 15px 5px;

Quando colocamos um único valor de dimensão para o preenchimento ou margem, esse mesmo 
valor é aplicado simetricamente a todas as direções.

Ex ==> padding: 10px;
Ex ==> margin: 10px;

Também existe a opção de indicar cada shorthand das propriedades de preenchimento
e borda usando apenas duas medidas:

Essa simplificação só é possível quando as medidas -top e -bottom forem iguais entre si e o mesmo também ocorrer entre as medidas -right e -left.

Ex ==> padding: 10px 5px;
Ex ==> margin: 10px 5px;


==> MARGENS NO AUTOMÁTICO


Um recurso que também vai ser muito usado em nossos exercícios é a centralização de blocos. 

Para que isso seja feito, devemos pedir que o navegador calcule automaticamente as margens da
esquerda e da direita para que o bloco seja colocado no meio do navegador, independente do tamanho da janela.

Para centralizar uma caixa, use a seguinte declaração no seu seletor:

==> margin: auto;



                                                        ==  SOMBRAS NAS CAIXAS  ==


Para adicionarmos sombras nas caixas basta colocar a propriedade "box-shadow" e seus quatro valores. 
A ordem é sempre essa: 

1. Deslocamento horizontal (h-offset): quanto a sombra vai andar para o lado
direito (valores negativos causam deslocamento para a esquerda)
2. Deslocamento vertical (v-offset): quanto a sombra vai andar para baixo (valores
negativos causam deslocamento para cima)
3. Embaçamento (blur): quanto a sombra vai se espalhar pelo fundo
4. Cor (color): cor da sombra. É possível usar transparência.



                                                       ==  BORDAS DECORADAS  ==


Vértices arredondados:

Podemos arredondar os vértices usando uma declaração simples usando a
propriedade "border-radius".

==> border-radius: 10px;

Na declaração acima, todos os vértices serão levemente arredondados (10px) de
forma simétrica. Se for necessário, podemos indicar quatro medidas diferentes, uma
para cada vértice, como está abaixo:

==> border-radius: 10px 20px 30px 40px;

também é possível indicar apenas dois valores, o que vai agir em vértices intercalados, 
partindo do canto superior esquerdo.

==> border-radius: 10px 30px



                                                        ==  VARIÁVEIS EM CSS  ==


Defina variáveis utilizando o exemplo abaixo:

:root {
    - - color0: #fff;
    - - fonte1: Arial, Helvetica, Sans-serif;
}

Chame as variáveis definidas usando o exemplo abaixo:

color: var(- - color0);
font-family: var(- - fonte1);



                                                        ==  MODULO 3 HTML E CSS  ==


                                       ==  IMAGEM DE FUNDO NO SITE (BACKGROUNDS)  ==


Informações sobre as propriedades do background em geral
==> https://developer.mozilla.org/pt-BR/docs/Web/CSS/background



==> background-image: url();

Todo elemento que funciona como uma caixa pode receber uma imagem de fundo dentro dele com a declaração "background-image:" , com a função "url()" , ficando:

mais informações sobre "background-image"
=> https://developer.mozilla.org/en-US/docs/Web/CSS/background-image~



==> background-position:

A propriedade "background-position" define a posição inicial de uma imagem de fundo. Por padrão, uma imagem de plano de fundo é colocada no canto superior esquerdo de um elemento e repetida tanto verticalmente quanto horizontalmente.

mais informações sobre "background-position"
=> https://developer.mozilla.org/en-US/docs/Web/CSS/background-position



==> background-repeat:

A propriedade "background-repeat" é usada para definir como uma imagem de fundo se repete na tela 

mais informações sobre "background-size"
=> https://developer.mozilla.org/en-US/docs/Web/CSS/background-repeat



==> background-size:

A propriedade "background-size" do CSS define o tamanho da imagem de fundo do elemento. 
A imagem pode ser deixada no seu tamanho natural, estendida ou comprimida para caber no espaço disponível.

mais informações sobre "background-size"  
=> https://developer.mozilla.org/pt-BR/docs/Web/CSS/background-size



==> background-attachment:

a propriedade CSS "background-attachment" determina se aquela posição da imagem é fixa com o viewport, ou se irá rolar juntamente com o seu bloco.

mais informações sobre "background-attachment"
https://developer.mozilla.org/pt-BR/docs/Web/CSS/background-attachment



Para usar shorthand no background, basta colocar os valores nesta odem:

color -> image -> position -> repeat -> [size] -> attachment

Obs: size não está funcionando no momento com o shorthand, então tem que coloca-lo separadamente em outra propriedade, no caso a propriedade "background-size"




                                              ==  CENTRALIZAÇÃO VERTICAL DE CAIXAS  ==


O elemento que for o container terá o posicionamento relativo (position: relative;) , eles já são naturalmente relativos, mas caso queira colocar o posicionamento por garantia, não tem problema.

O conteúdo que é a parte de dentro vai ter o posicionamento absoluto (position: absolute;) , quando definimos o canteúdo como absoluto, podemos configurar duas propriedades muito importantes:

==> left e top

O valor que será definido em left, será a distancia que o conteúdo se afastará da esquerda do container.
O valor que será definido em top, será a distancia que o conteúdo se afastará do topo do container.

Obs: Sempre essas propriedades tomarão como base de posicionamento o canto superior esquedo do conteúdo

Isso se resolve colocando a propriedade "transform" com a função "translate()", o transform permite fazer zoom, dar perspectivas, alteração de escala ou rodar elementos, e a função translate() reposiciona um elemento na direção horizontal e/ou vertical.

Saiba mais sobre o transform ==> https://developer.mozilla.org/pt-BR/docs/Web/CSS/transform



                                                          == TUDO SOBRE DISPLAY ==


A propriedade "display" define o comportamento do elemento em relação aos demais elementos do documento. Originalmente, o código possuia dois tipos de elementos: inline, apresentados no navegador de forma contínua, como conteúdo; e block, apresentados no navegador como blocos de separação e organização do conteúdo.

Uso de alguns valores de exibição diferentes:

-> display: none;
-> display: inline;
-> display: block;
-> display: inline-block;

Desativando a renderização do elemento HTML no bloco: none
Quando definimos um elemento com CSS display none, significa que ele e os seus elementos filhos não são exibidos na tela.
-----> display: none;


Renderizando o elemento HTML embutido no container: inline
O valor CSS display inline é utilizado quando queremos que os elementos fiquem posicionados lado a lado. É importante dizer que, ao utilizar esse valor, as propriedades width (largura) e height (altura) serão ignoradas se forem definidas no código CSS.
-----> display: inline;


Renderizando o elemento HTML como um container: block
Quando atribuímos o valor CSS display block à propriedade, significa que o elemento será posicionado em uma nova linha.
-----> display: block;


Definindo propriedades de largura e altura para o elemento HTML: inline-block
Ao utilizarmos o valor CSS display inline-block podemos organizar os elementos lado a lado e definirmos as propriedades de largura e altura, pois elas não serão ignoradas pelo navegador.
----> display: inline-block;


Saiba mais: https://blog.betrybe.com/css/css-display/
Saiba mais: https://developer.mozilla.org/pt-BR/docs/Web/CSS/display



                                                  == TUDO SOBRE BOX-SIZING ==


A propriedade CSS box-sizing é utilizada para alterar a propriedade padrão da box model, usada para calcular larguras (widths) e alturas (heights) dos elementos. É possível usar essa propriedade para emular o comportamento dos navegadores (browsers) que não suportam corretamente a especificação da propriedade CSS box model.

Valores:

-----> border-box
As propriedades de largura (width) e de altura (height) incluem o tamanho padding size e a propriedade border, mas não incluem a propriedade margin.


-----> content-box
Essa é o estilo padrão, conforme especificado pela norma CSS. As propriedades width (largura) e height (altura) são medidas incluindo só o conteúdo, mas não o padding, border ou margin. Nota: Padding, border e margin serão fora da box. Exemplo.: Se .box {width: 350px} então se você aplicar uma propriedade {border: 10px solid black;} o resultado renderizado no navegador (browser) será .box {width: 370px;}


-----> padding-box
As propriedades de largura (width) e de altura (height) incluem o tamanho padding size, mas não incluem a propriedade border ou margem.


Saiba mais -> https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing



                                            ==  INFORMAÇÕES SOBRE TABELAS  ==


A propriedade CSS "border-collapse" define se as células dentro do elemento <table> possuem bordas grudadas ou separadas.

A propriedade "border-collapse" é especificada como um único valor, que pode ser escolhido na lista abaixo.

-----> collapse
     As células adjacentes têm bordas compartilhadas (o modelo de renderização de tabela com                   bordas grudadas).
Ex: border-collapse: collapse;


-----> separate
     As células adjacentes têm bordas distintas (o modelo de renderização de tabela com bordas                separadas).
Ex: border-collapse: separate;

Valor inicial :     separate
Aplica-se a :      elemento <table> e valor inline-table (display: inline-table;)

Saiba mais -> https://developer.mozilla.org/en-US/docs/Web/CSS/border-collapse



                                                     == VERTICAL - ALIGN (TABELAS) ==


A propriedade "vertical-align" do CSS define o alinhamento vertical de uma caixa inline, inline-block ou table-cell.

A propriedade "vertical-align" pode ser usada em dois contextos:


Para alinhar verticalmente a caixa de um elemento inline dentro da caixa de linha que a contém. Por exemplo, pode ser usado para posicionar verticalmente uma imagem em uma linha de texto.

Para alinhar verticalmente o conteúdo de uma célula em uma tabela.


Observe que "vertical-align" só se aplica a elementos inline, inline-block e table-cell: 
você não pode usá-lo para alinhar verticalmente elementos em nível de bloco.

Valores para células da tabela :

-----> top
     Alinha a borda de preenchimento superior da célula com a parte superior da linha.
Ex: vertical-align: top;


-----> middle
     Centraliza a caixa de preenchimento da célula dentro da linha.
Ex: vertical-align: middle;


-----> bottom
     Alinha a borda de preenchimento inferior da célula com a parte inferior da linha.
Ex: vertical-align: bottom;

Saiba mais -> https://developer.mozilla.org/pt-BR/docs/Web/CSS/vertical-align



                                            == CABEÇALHO FIXO EM TABELAS GRANDES ==


Para deixar o cabeçalho fixo no topo da tabela, primeiramente o elemento <table> tem que receber um -----> position: relative

Depois basta colocar nos elementos table > tr > th , as propriedades: 

-----> position: sticky
-----> top: -1px

Assim o cabeçalho da tabela ficará fixo, seguindo as informações da tabela e descendo junto com elas.



                                                     == EFEITO ZEBRADO (TABELAS) == 


A pseudo-classe CSS :nth-child() seleciona elementos com base em suas posições em um grupo de elementos irmãos.
é usada com apenas um argumento, que representa o padrão usado para selecionar os elementos.

Valores: 

-----> odd
Representa elementos cuja posição numérica em uma série de irmãos seja ímpar: 1, 3, 5, etc.

-----> even
Representa elementos cuja posição numérica em uma série de irmãos seja par: 2, 4, 6, etc.

-----> 2n , 2n+1 , 2n+alguma coisa  (opções extras)

Saiba mais ->https://developer.mozilla.org/pt-BR/docs/Web/CSS/:nth-child



                                          ==  RESPONSIVIDADE EM TABELAS OU OUTROS  ==


A propriedade CSS overflow especifica quando o conteúdo de um elemento de nível de bloco deve ser cortado, exibido com barras de rolagem ou se transborda do elemento.

Sintaxe --> overflow:  visible | hidden | scroll | auto | inherit

Valores:

-----> visible
Valor padrão. O conteúdo não é cortado e pode ser renderizado para fora da caixa de conteúdo.

-----> hidden
O conteúdo é cortado e nenhuma barra de rolagem é exibida.

-----> scroll
O conteúdo é acessível através de barras de rolagem que são exibidas mesmo que o conteúdo não precise. Isso evita o problema de barras de rolagem aparecendo e desaparecendo quando o conteúdo é dinâmico. Impressoras podem imprimir o conteúdo vazado.

-----> auto
Depende do navegador utilizado. Navegadores desktop como o Firefox geralmente exibem barras de rolagem apenas quando necessário.

Saiba mais -> https://developer.mozilla.org/pt-BR/docs/Web/CSS/overflow



                                                       ==  MODULO 4 HTML E CSS  ==                                                         


                                                             ==  MEDIA QUERIES  ==


Uma media query consiste de um media type e pelo menos uma expressão que limita o escopo das folhas de estilo usando media features, tal como largura, altura e cor. Media queries, adicionadas no CSS3, deixam a apresentação do conteúdo adaptado a uma gama especifica de dispositivos não precisando mudar o conteúdo em si.


-----> media query = media type + media features


-----> media types 
são os tipos de midia, eles são:

• all — para todos os tipos de mídia
 
• print — para impressoras

• screen — para telas de computador, tablets e smartphones

• speech — para leitores de tela que “leem” a página em voz alta


----> media features 
são características de mídia


Sintaxe :

Media queries consistem de um media type e podem, a partir de uma especificação CSS3, contendo uma ou mais expressões, expressa em media features, que determinam ou verdadeiro ou falso. Os resultados da query são verdadeiros se o media type especificado na media query corresponde ao tipo do documento exibido no dispositivo e todas as expressões na media query são verdadeiras.

• HTML
-----> CSS media query em um elemento de link 

<link rel="stylesheet" media="(max-width: 800px)" href="example.css" />


• CSS
-----> CSS media query dentro de um stylesheet 

@media (max-width: 600px) {
  .facet_sidebar {
    display: none;
  }
}


Quando uma media query é verdadeira, a camada de estilo ou as regras de estilos correspondentes são aplicadas, seguindo o padrão de regras de cascatas. Camadas de estilos com media queries ligadas a tag <link> vão fazer download mesmo se suas medias queries retornarem falso (eles não se aplicam, no entanto).

A menos que você use os operadores not ou only, o media type é opcional e o tipo all será implícito.

Saiba mais -> 
https://developer.mozilla.org/pt-BR/docs/Web/CSS/CSS_media_queries/Using_media_queries



                                          ==  OPERADORES LÓGICOS (MEDIA QUERY)  ==


Você pode compor media queries complexos usando operadores lógicos, incluindo not, and, e only.

Se você usar os operadores not ou only, você tem que especificar um tipo de media explícito.

Você também pode combinar múltiplas medias queries em uma lista separadas por vírgulas, se qualquer uma das media queries na lista é verdadeira, toda a instrução retorna verdadeira. Isto é equivalente a um operador or.


-----> and
é usado para combinar múltiplas media features em uma mesma media query, requerendo que cada sequência de características, retorne verdadeiro na ordem para que a query seja verdadeiro. Media types são indicadas sem parênteses, e media features são indicadas entre parênteses.

• exemplo: @media screen and (orientation: landscape)


-----> not
O operador not é usado para negar uma media query inteira.


-----> only
O operador only é usado para aplicar um estilo apenas se a query inteira for igual, útil para previnir que navegadores antigos apliquem os estilos selecionados.

Saiba MUITO mais -> 
https://developer.mozilla.org/pt-BR/docs/Web/CSS/CSS_media_queries/Using_media_queries



                                               ===  TYPICAL DEVICE BREAKPOINTS  ===


Breakpoints são, talvez, o termo mais comum que você ouvirá e usará ao falarmos de media queries. Um breakpoint é uma chave para determinar o momento de mudar o layout e adaptá-lo às novas regras dentro das media queries.

Os typicals device breakpoints estão disponíveis para: celular, tablets, Desktops e TVs


Exemplo de breakpoints

@media (max-width: 480px) {
  .text {
    font-size: 16px;
  }
}

Aqui, o breakpoint é 480px. Agora, a media query sabe quando definir ou sobrescrever a nova classe. Basicamente, se a largura de um dispositivo for inferior a 480px, a classe text será aplicada. Do contrário, isso não acontece.


breakpoints comuns em termos de larguras dos dispositivos:

• 600px e abaixo —  pequenas telas

• 601px — 768px (portrait):  tablets e celulares largos 

• 769px — 992px (landscape) :  tablets, laptops

• 993px — 1200px: desktops, telas grandes

• 1201px e acima —  telas muito grandes, TVs

Usar o design responsivo é uma obrigação nos campos de design e desenvolvimento para a web nos dias de hoje. Media queries são uma das partes mais importantes na criação de layouts responsivos.



                                                           ===  MOBILE FIRST  ===


Mobile First é um conceito aplicado em projetos web onde o foco inicial da arquitetura e desenvolvimento é direcionado aos dispositivos móveis.

O conceito de Mobile First foi elaborado por Luke Wroblewski em 2009 e 2010 no seu blog e no ano seguinte ele publicou através da A Book Apart o livro Mobile First que é uma leitura obrigatória para aqueles que queiram compreender a fundo a técnica e suas aplicabilidades.


• Vantagens de se usar Mobile first:


-----> Facilidade na divulgação do seu site
O algoritmo do google valoriza sites produzidos com foco em Mobile First.


-----> Melhoria na experiência do usuário
Quando se pensa primeiro na versão móvel, pensando em deixar o conteúdo o mais leve, rápido e eficiente possível, acabamos melhorando a experiência do usuário e consequentemente o algoritmo do google nos da uma vantagem por conta disso.


-----> Aumento de credibilidade
Instintivamente (sem ser algo racional) quem está visitando seu site pensa na sua marca/site/conteúdo, como algo totalmente profissional, por conta do conteúdo, da leveza e da rapidez do site, isso acaba aumentando a credibilidade do seu site.


-----> Performance 
Sites móveis tem que ser mais leves porque muitas pessoas acessam sites com celular no meio da rua com conexões precárias, então se seu site tiver uma boa performance, vai facilitar a entrada dessas pessoas no seu site.


Saiba mais -> https://blog.apiki.com/mobile-first-o-conceito-e-sua-aplicabilidade/








